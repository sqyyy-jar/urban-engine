from typing import Any
from instructions import mapped


layer2_name_mappings = {
    "ldr": "ldr",
    "str": "str",
    "ldrb": "ldr_byte",
    "ldrh": "ldr_half",
    "ldrw": "ldr_word",
    "strb": "str_byte",
    "strh": "str_half",
    "strw": "str_word",
}


def gen_insn_(file, insn: dict[str, Any], layered: bool):
    name = insn["name"]
    registers = insn["registers"]
    size = insn["size"]
    signed = insn["signed"]
    index = insn["index"]
    gen_documentation(file, name, registers, size, signed)
    gen_start_constant(file, name, registers, layered, index, size)
    gen_end_constant(file, name, registers, layered, index, size)


def gen_documentation(file, name: str, registers: int, size: int, signed: bool):
    print(f"/// `{name}", file=file, end="")
    for i in range(registers):
        if i != 0:
            print(",", file=file, end="")
        print(f" X{i}", file=file, end="")
    if size > 0:
        if registers > 0:
            print(",", file=file, end="")
        if signed:
            print(f" i{size}", file=file, end="")
        else:
            print(f" u{size}", file=file, end="")
    print("`", file=file)


def gen_start_constant(
    file, name: str, registers: int, layered: bool, index: int, size: int
):
    mangled_name = mangle_name(name, size, layered)
    mid_bits = 27 - registers * 5 - size
    if layered:
        mid_bits -= 6
    print(f"pub const INSN_{mangled_name}: u32 = 0b", file=file, end="")
    if layered:
        print("1" * 5, file=file, end="")
    else:
        print(f"{index:05b}", file=file, end="")
    print("_", file=file, end="")
    if layered:
        print(f"{index:06b}_", file=file, end="")
    print("0" * mid_bits, file=file, end="")
    if mid_bits > 0 and size > 0:
        print("_", file=file, end="")
    print("0" * size, file=file, end="")
    for _ in range(registers):
        print(f"_{'0' * 5}", file=file, end="")
    print(";", file=file)


def gen_end_constant(
    file, name: str, registers: int, layered: bool, index: int, size: int
):
    mangled_name = mangle_name(name, size, layered)
    mid_bits = 27 - registers * 5 - size
    if layered:
        mid_bits -= 6
    print(f"pub const ENDINSN_{mangled_name}: u32 = 0b", file=file, end="")
    if layered:
        print("1" * 5, file=file, end="")
    else:
        print(f"{index:05b}", file=file, end="")
    print("_", file=file, end="")
    if layered:
        print(f"{index:06b}_", file=file, end="")
    print("0" * mid_bits, file=file, end="")
    if mid_bits > 0 and size > 0:
        print("_", file=file, end="")
    print("1" * size, file=file, end="")
    for _ in range(registers):
        print(f"_{'1' * 5}", file=file, end="")
    print(";", file=file)


def mangle_name(name: str, size: int, layered: bool) -> str:
    if layered and name in layer2_name_mappings:
        return layer2_name_mappings[name].upper()
    if size == 0:
        return name.replace(".", "_").upper()
    else:
        return f"{name.replace('.', '_').upper()}_IMMEDIATE"


def write(file):
    layers = mapped()
    l1 = layers[0]
    l2 = layers[1]
    print(
        """
// This file is automatically generated.
// It is not intended for manual editing.

//! This module contains constants for all instructions
//!
//! ## Instruction
//!
//! ### Layer 1
//!
//! 0bXXXXX_000000000000000000000000000
//!
//! ### Layer 2
//!
//! 0b11111_XXXXXX_000000000000000000000
//!
//! `X` represents the id of the instruction in its layer

#![allow(clippy::unusual_byte_groupings)]
    """.strip(),
        file=file,
    )
    print(file=file)
    for insn in l1:
        gen_insn_(file, insn, False)
    for insn in l2:
        gen_insn_(file, insn, True)
