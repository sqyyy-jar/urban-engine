using System.Globalization;
using System.Text;

namespace urban_codegen.codegen;

public class Java : Codegen
{
    public void Run(Instructions instructions)
    {
        Directory.CreateDirectory("gen/java");
        OpCodes(instructions);
        Builder(instructions);
    }

    private static void OpCodes(Instructions instructions)
    {
        var opcodesFile = File.Create("gen/java/OpCodes.java");
        var opcodes = new StreamWriter(opcodesFile);
        opcodes.WriteLine($$"""
            // This file is automatically generated.
            // It is not intended for manual editing.

            /**
             * This module contains opcode constants for ISA version {@code {{instructions.Version}}}.
             */
            public class OpCodes {
            """);
        var layerId = 0;
        foreach (var layer in instructions.Layers)
        {
            foreach (var instruction in layer.Instructions)
            {
                var name = instruction.Name.ToUpper().Replace('.', '_');
                opcodes.WriteLine("    /**");
                opcodes.Write($"     * {{@code {instruction.Name}");
                foreach (var component in instruction.Components)
                {
                    opcodes.Write($" {component.DocString}");
                }

                opcodes.WriteLine("}");
                opcodes.WriteLine("     */");
                opcodes.Write($"    public static final int L{layerId}_{name} = 0b");
                var startBuilder = new StringBuilder();
                startBuilder.Append(string.Concat(Enumerable.Repeat('1', (int)layer.PrefixBits)));
                if (layer.PrefixBits > 0)
                {
                    startBuilder.Append('_');
                }

                var index = Convert.ToString(instruction.Index, 2);
                startBuilder.Append(string.Concat(Enumerable.Repeat('0', (int)layer.Bits - index.Length)));
                startBuilder.Append(index);
                if (instruction.LostBits > 0)
                {
                    startBuilder.Append('_');
                    startBuilder.Append(string.Concat(Enumerable.Repeat('0', (int)instruction.LostBits)));
                }

                var start = startBuilder.ToString();
                opcodes.Write(start);
                foreach (var component in instruction.Components)
                {
                    opcodes.Write('_');
                    opcodes.Write(string.Concat(Enumerable.Repeat('0', (int)component.Bits)));
                }

                opcodes.WriteLine(";");
                opcodes.Write($"    public static final int END_L{layerId}_{name} = 0b");
                opcodes.Write(start);
                foreach (var component in instruction.Components)
                {
                    opcodes.Write('_');
                    opcodes.Write(string.Concat(Enumerable.Repeat('1', (int)component.Bits)));
                }

                opcodes.WriteLine(";");
            }

            layerId++;
        }

        opcodes.WriteLine("}");
        opcodes.Flush();
        opcodesFile.Close();
    }

    private static void Builder(Instructions instructions)
    {
        var file = File.Create("gen/java/BinaryBuilder.java");
        var fileStream = new StreamWriter(file);
        fileStream.WriteLine($$"""
// This file is automatically generated.
// It is not intended for manual editing.

import java.util.List;
import java.util.ArrayList;
import java.util.Objects;
import java.io.IOException;
import java.io.OutputStream;

/**
 * This module contains a binary builder for ISA version {@code {{instructions.Version}}}.
 */
public class BinaryBuilder {
    protected final List<Module> includedModules = new ArrayList<>();
    protected final List<CompiledFunction> includedFunctions = new ArrayList<>();
    protected final List<Function> functions = new ArrayList<>();

    public BinaryBuilder use(Module module) {
        Objects.requireNonNull(module);
        includedModules.add(module);
        return this;
    }

    public BinaryBuilder use(CompiledFunction function) {
        Objects.requireNonNull(function);
        includedFunctions.add(function);
        return this;
    }

    public BinaryBuilder func(Function function) {
        Objects.requireNonNull(function);
        functions.add(function);
        return this;
    }

    public enum Register {
        R0(0), R1(1), R2(2), R3(3), R4(4), R5(5), R6(6), R7(7), R8(8), R9(9), R10(10), R11(11), R12(12), R13(13), R14(14),
        R15(15), R16(16), R17(17), R18(18), R19(19), R20(20), R21(21), R22(22), R23(23), R24(24), R25(25), R26(26), R27(27),
        R28(28), R29(29), R30(30), R31(31);

        private final int num;

        Register(int num) {
            this.num = num;
        }

        public int num() {
            return num;
        }
    }

    public interface Constant {
        int size();

        void write(Function function, OutputStream out) throws IOException;
    }

    public interface Instruction {
        int num(Function function);
    }

    public record LongConstant(long value) implements Constant {
        @Override
        public int size() {
            return 8;
        }

        @Override
        public void write(Function function, OutputStream out) throws IOException {
            out.write((int) value);
            out.write((int) (value >> 8));
            out.write((int) (value >> 16));
            out.write((int) (value >> 24));
            out.write((int) (value >> 32));
            out.write((int) (value >> 40));
            out.write((int) (value >> 48));
            out.write((int) (value >> 56));
        }
    }

    public record RawInstruction(int num) implements Instruction {
        @Override
        public int num(Function function) {
            return num;
        }
    }

    public static class Module {
    }

    public static class CompiledFunction {
    }

    public static class Function {
        protected final BinaryBuilder parent;
        protected final String name;
        protected final List<Constant> constants = new ArrayList<>();
        protected final List<Instruction> instructions = new ArrayList<>();

        protected Function(BinaryBuilder parent, String name) {
            this.parent = parent;
            this.name = name;
        }

        public BinaryBuilder getParent() {
            return parent;
        }

        public String getName() {
            return name;
        }
""");
        var layerId = 0;
        foreach (var layer in instructions.Layers)
        {
            foreach (var instruction in layer.Instructions)
            {
                fileStream.WriteLine();
                var constName = instruction.Name.ToUpper().Replace('.', '_');
                var parts = instruction.Name.Split('.');
                var nameBuilder = new StringBuilder();
                nameBuilder.Append(parts[0]);
                var textInfo = new CultureInfo("en-US").TextInfo;
                for (var i = 1; i < parts.Length; i++)
                {
                    nameBuilder.Append(textInfo.ToTitleCase(parts[i]));
                }

                var name = nameBuilder.ToString();
                fileStream.WriteLine("        /**");
                fileStream.Write($"         * {{@code {instruction.Name}");
                foreach (var component in instruction.Components)
                {
                    fileStream.Write($" {component.DocString}");
                }

                fileStream.WriteLine("}");
                fileStream.WriteLine("         */");
                switch (name)
                {
                    case "int":
                        fileStream.Write("        public Function interrupt(");
                        break;
                    default:
                        fileStream.Write($"        public Function {name}(");
                        break;
                }

                var j = 0;
                foreach (var component in instruction.Components)
                {
                    if (j != 0)
                    {
                        fileStream.Write(", ");
                    }

                    switch (component)
                    {
                        case Register r:
                            fileStream.Write($"Register {r.Name}");
                            break;
                        case UnsignedImmediate u:
                            fileStream.Write($"long {u.Name}");
                            break;
                        case SignedImmediate i:
                            fileStream.Write($"long {i.Name}");
                            break;
                    }

                    j++;
                }

                fileStream.WriteLine(") {");
                if (instruction.Components.Count == 0)
                {
                    fileStream.WriteLine(
                        $"            instructions.add(new RawInstruction(OpCodes.L{layerId}_{constName}));");
                }
                else
                {
                    fileStream.WriteLine($"            var opcode = OpCodes.L{layerId}_{constName};");
                    var k = 0u;
                    foreach (var component in instruction.Components)
                    {
                        fileStream.Write("            opcode |= ");
                        var pattern = (1u << (int)component.Bits) - 1;
                        switch (component)
                        {
                            case Register r:
                                fileStream.Write(k == 0
                                    ? $"{r.Name}.num() & 0x{pattern:x}"
                                    : $"({r.Name}.num() & 0x{pattern:x}) << {k}");
                                break;
                            default:
                                fileStream.Write(k == 0
                                    ? $"{component.Name} & 0x{pattern:x}"
                                    : $"({component.Name} & 0x{pattern:x}) << {k}");
                                break;
                        }

                        fileStream.WriteLine(";");
                        k += component.Bits;
                    }

                    fileStream.WriteLine("            instructions.add(new RawInstruction(opcode));");
                }

                fileStream.WriteLine("""
            return this;
        }
""");
            }

            layerId++;
        }

        fileStream.WriteLine("""
    }
}
""");
        fileStream.Flush();
        file.Close();
    }
}